# -*- coding: utf-8 -*-
"""Study Case DA - Step 1 (Final Fix).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NIGg7siSDvvSVOYVIgdRXuJN8YgSQ91E

# Import and Load Data
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from scipy.stats import chi2_contingency
from math import pi

data_scda = "Study Case DA.xlsx"

employees = pd.read_excel(data_scda, sheet_name='employees')
dim_companies = pd.read_excel(data_scda, sheet_name='dim_companies').rename(columns={'name': 'company_name'})
dim_areas = pd.read_excel(data_scda, sheet_name='dim_areas').rename(columns={'name': 'area_name'})
dim_positions = pd.read_excel(data_scda, sheet_name='dim_positions').rename(columns={'name': 'position_name'})
dim_departments = pd.read_excel(data_scda, sheet_name='dim_departments').rename(columns={'name': 'department_name'})
dim_divisions = pd.read_excel(data_scda, sheet_name='dim_divisions').rename(columns={'name': 'division_name'})
dim_directorates = pd.read_excel(data_scda, sheet_name='dim_directorates').rename(columns={'name': 'directorate_name'})
dim_grades = pd.read_excel(data_scda, sheet_name='dim_grades').rename(columns={'name': 'grade_name'})
dim_education = pd.read_excel(data_scda, sheet_name='dim_education').rename(columns={'name': 'education_name'})
dim_majors = pd.read_excel(data_scda, sheet_name='dim_majors').rename(columns={'name': 'major_name'})
performance = pd.read_excel(data_scda, sheet_name='performance_yearly')
competencies = pd.read_excel(data_scda, sheet_name='competencies_yearly')
competency_pillars = pd.read_excel(data_scda, sheet_name='dim_competency_pillars')
profiles_psych = pd.read_excel(data_scda, sheet_name='profiles_psych')
papi_scores = pd.read_excel(data_scda, sheet_name='papi_scores')
strengths = pd.read_excel(data_scda, sheet_name='strengths')

"""Merge Employee Data with Dim Tables"""

emp_merged = (
    employees
    .merge(dim_companies, how='left', on='company_id')
    .merge(dim_areas, how='left', on='area_id')
    .merge(dim_positions, how='left', on='position_id')
    .merge(dim_departments, how='left', on='department_id')
    .merge(dim_divisions, how='left', on='division_id')
    .merge(dim_directorates, how='left', on='directorate_id')
    .merge(dim_grades, how='left', on='grade_id')
    .merge(dim_education, how='left', on='education_id')
    .merge(dim_majors, how='left', on='major_id')
)

"""Rename Columns For Readability"""

emp_merged = emp_merged.rename(columns={
    'company_name': 'company',
    'area_name': 'area',
    'position_name': 'position',
    'department_name': 'department',
    'division_name': 'division',
    'directorate_name': 'directorate',
    'grade_name': 'grade',
    'education_name': 'education',
    'major_name': 'major'
})

"""Remove Redundant ID Columns"""

emp_merged = emp_merged.drop(columns=[
    'company_id', 'area_id', 'position_id', 'department_id', 'division_id',
    'directorate_id', 'grade_id', 'education_id', 'major_id'
])

"""Reorder Columns For Clean Output"""

cols = list(emp_merged.columns)

if 'years_of_service_months' in cols:
    cols.append(cols.pop(cols.index('years_of_service_months')))

emp_merged = emp_merged[cols]

emp_merged.head(5)

emp_merged['employee_id'].duplicated().any()

"""# Prepare Contextual + Perfomance Data"""

# 1. Get the most recent performance record per employee
performance_final = (
    performance
    .sort_values('year')
    .drop_duplicates('employee_id', keep='last')
)

# 2. Merge employee master with performance ratings
emp_perf = (
    emp_merged
    .merge(
        performance_final[['employee_id', 'rating']],
        on='employee_id',
        how='left'
    )
)

# 3. Add Top vs Non-Top Performer label
emp_perf['top_flag'] = np.where(
    emp_perf['rating'] == 5,
    'Top Performer',
    'Non-Top Performer'
)


print("Contextual + Performance Data")
print("Shape:", emp_perf.shape)
emp_perf.head()

"""# Contextual Analysis"""

# Distribution of Performance Ratings
plt.figure(figsize=(6,4))
sns.countplot(
    x='rating',
    data=emp_perf,
    palette='crest'
)
plt.title("Distribution of Employee Ratings", fontsize=12, weight='bold')
plt.xlabel("Rating")
plt.ylabel("Count")
plt.tight_layout()
plt.show()

"""a) Education Analysis"""

# Count Top vs Non-Top by Education Level
edu_counts = (
    emp_perf
    .groupby(['education', 'top_flag'])
    .size()
    .unstack(fill_value=0)
)

# Calculate Top Performer Percentage per Education Level
edu_counts['Top Performer (%)'] = (
    edu_counts['Top Performer'] /
    (edu_counts['Top Performer'] + edu_counts['Non-Top Performer'])
) * 100

# Sort descending by Top Performer percentage
edu_counts = edu_counts.sort_values('Top Performer (%)', ascending=False)


print("Top Performer Percentage by Education Level:\n")
print(edu_counts[['Top Performer (%)']].round(2).head(10))

plt.figure(figsize=(7,5))
colors = plt.cm.Blues(np.linspace(0.8, 0.4, len(edu_counts)))
plt.bar(edu_counts.index, edu_counts['Top Performer (%)'], color=colors, alpha=0.5, width=0.6)


for i, v in enumerate(edu_counts['Top Performer (%)']):
    plt.text(i, v + 0.2, f'{v:.1f}%', ha='center', fontsize=9)

plt.title('Top Performer % by Education Level', fontweight='bold')
plt.ylabel('Percentage')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""b) Year of Service"""

# Average years of service by performance group
avg_service = (
    emp_perf.groupby('top_flag')['years_of_service_months']
    .mean()
    .round(2)
    .reset_index()
    .rename(columns={'years_of_service_months': 'avg_years_of_service'})
)

print("Average Years of Service (Months):")
print(avg_service)

plt.figure(figsize=(7,5))
sns.violinplot(x='top_flag', y='years_of_service_months', data=emp_perf, palette='Blues')
plt.title('Distribution of Years of Service by Performance Group', fontsize=12, weight='bold')
plt.xlabel('')
plt.ylabel('Years of Service (Months)')
plt.tight_layout()
plt.show()

"""c) Major"""

# Group by major and top_flag
maj_counts = (
    emp_perf.groupby(['major', 'top_flag'])
    .size()
    .unstack(fill_value=0)
)

# Calculate top performer percentage
maj_counts['Top Performer (%)'] = (
    maj_counts['Top Performer'] /
    (maj_counts['Top Performer'] + maj_counts['Non-Top Performer'])
) * 100

# Sort descending by percentage
maj_counts = maj_counts.sort_values('Top Performer (%)', ascending=False)


print("Top Performer Ratio by Major:\n")
print(maj_counts[['Top Performer (%)']].round(2).head(10))

maj_top10 = maj_counts[['Top Performer (%)']].head(10).sort_values('Top Performer (%)')

# plot lollipop chart
plt.figure(figsize=(7,5))
plt.hlines(
    y=maj_top10.index,
    xmin=0,
    xmax=maj_top10['Top Performer (%)'],
    color='skyblue',
    linewidth=3
)
plt.plot(
    maj_top10['Top Performer (%)'],
    maj_top10.index,
    'o',
    color='blue'
)


for y, x in enumerate(maj_top10['Top Performer (%)']):
    plt.text(x + 0.3, y, f"{x:.1f}%", va='center', fontsize=9)


plt.title('Top Performer Percentage by Major', fontsize=12, weight='bold')
plt.xlabel('Top Performer (%)')
plt.ylabel('Major')
plt.tight_layout()
plt.show()

"""d) Grade"""

# Proportion of Top Performers by Grade
plt.figure(figsize=(7,5))
ax = sns.countplot(
    y='grade',
    hue='top_flag',
    data=emp_perf,
    palette='coolwarm'
)

plt.title("Top Performer Proportion by Grade", fontsize=12, weight='bold')
plt.xlabel("Count")
plt.ylabel("Grade")


for p in ax.patches:

    width = p.get_width()
    y = p.get_y() + p.get_height() / 2


    ax.text(width + 5, y, int(width), ha='left', va='center', fontsize=9)


plt.legend(title="")
plt.tight_layout()
plt.show()

# Define Cramer's V function
def cramers_v(x, y):
    confusion_matrix = pd.crosstab(x, y)
    chi2 = chi2_contingency(confusion_matrix)[0]
    n = confusion_matrix.sum().sum()
    phi2 = chi2 / n
    r, k = confusion_matrix.shape
    return np.sqrt(phi2 / min(k - 1, r - 1))


results = []
for col in ['grade', 'education', 'major']:
    contingency = pd.crosstab(emp_perf[col], emp_perf['top_flag'])
    chi2, p, dof, expected = chi2_contingency(contingency)
    cv = cramers_v(emp_perf[col], emp_perf['top_flag'])
    results.append({'Variable': col, 'Cramer_V': round(cv, 3), 'p_value': round(p, 4)})

pd.DataFrame(results)

"""# Competency Analysis"""

# 1. Merge competency data with pillar info and top_flag label
comp_full = (
    competencies
    .merge(competency_pillars, on='pillar_code', how='left')
    .merge(emp_perf[['employee_id', 'top_flag']], on='employee_id', how='left')
)

# 2. Calculate average score per pillar by performance group
pillars_avg = (
    comp_full
    .groupby(['pillar_label', 'top_flag'])['score']
    .mean()
    .unstack()
)

# 3. Compute difference (Top - Non-Top) in percentage points
pillars_avg['diff'] = (pillars_avg['Top Performer'] - pillars_avg['Non-Top Performer']) * 100
pillars_avg = pillars_avg.sort_values('diff', ascending=False)

# 4. Display table
print("Average competency score difference (Top vs Non-Top) [%]:\n")
print(pillars_avg[['diff']].round(2).head(10))

# 5. Visualization
plt.figure(figsize=(7,5))
ax = sns.barplot(
    x='diff',
    y='pillar_label',
    data=pillars_avg.reset_index(),
    palette='viridis'
)

plt.title("Difference in Average Competency Score (Top â€“ Non-Top) [%]", fontsize=12, weight='bold')
plt.xlabel("Score Difference (%)")
plt.ylabel("Competency Pillar")


for i, v in enumerate(pillars_avg['diff']):
    ax.text(v + 0.2, i, f"{v:.2f}%", va='center', fontsize=9)

plt.tight_layout()
plt.show()

comp_full.head()

# 1. Prepare data
if 'Top Performer' in pillars_avg.columns and 'Non-Top Performer' in pillars_avg.columns:
    radar_data = pillars_avg[['Non-Top Performer', 'Top Performer']].copy()
elif 0 in pillars_avg.columns and 1 in pillars_avg.columns:
    radar_data = pillars_avg[[0, 1]].copy()
    radar_data.columns = ['Non-Top Performer', 'Top Performer']
else:
    raise ValueError("Expected columns for Top/Non-Top Performer not found in pillars_avg")

categories = radar_data.index.tolist()

# 2. Normalize values (0â€“1 range)
radar_data_norm = (radar_data - radar_data.min()) / (radar_data.max() - radar_data.min())

# 3. Set angles for radar
N = len(categories)
angles = [n / float(N) * 2 * pi for n in range(N)]
angles += angles[:1]  # close the shape

# 4. Plot setup
plt.figure(figsize=(10,9))
ax = plt.subplot(111, polar=True)
plt.xticks(angles[:-1], categories, fontsize=9)
ax.set_rlabel_position(0)
plt.yticks([0.2,0.4,0.6,0.8,1.0], ["20%","40%","60%","80%","100%"], color="grey", size=8)
plt.ylim(0,1)

# 5. Plot Non-Top Performer
values = radar_data_norm.loc[:, 'Non-Top Performer'].tolist()
values += values[:1]
ax.plot(angles, values, linewidth=1.5, linestyle='solid', color='#1f77b4', label='Non-Top Performer')
ax.fill(angles, values, color='#1f77b4', alpha=0.15)

# 6. Plot Top Performer
values = radar_data_norm.loc[:, 'Top Performer'].tolist()
values += values[:1]
ax.plot(angles, values, linewidth=2, linestyle='solid', color='#ff7f0e', label='Top Performer')
ax.fill(angles, values, color='#ff7f0e', alpha=0.2)

# 7. Final touches
plt.title('Competency Profile Comparison â€“ Top vs Non-Top Performer', size=13, weight='bold', pad=20)
plt.legend(loc='upper right', bbox_to_anchor=(1.15, 1.1))
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
from scipy import stats

# Encode biner
comp_full['top_flag_bin'] = comp_full['top_flag'].apply(lambda v: 1 if v == 'Top Performer' else 0)

correlation_results = []

for pillar in comp_full['pillar_label'].unique():
    subset = comp_full[comp_full['pillar_label'] == pillar].dropna(subset=['score', 'top_flag_bin'])


    if subset['top_flag_bin'].nunique() < 2 or subset['score'].nunique() < 2:
        continue


    r, p = stats.pointbiserialr(subset['score'], subset['top_flag_bin'])


    if abs(r) < 0.1:
        strength = "Very Weak"
    elif abs(r) < 0.3:
        strength = "Weak"
    elif abs(r) < 0.5:
        strength = "Moderate"
    else:
        strength = "Strong"

    correlation_results.append({
        'pillar_label': pillar,
        'r_pointbiserial': round(r, 3),
        'p_value': round(p, 4),
        'strength': strength
    })

corr_df = pd.DataFrame(correlation_results).sort_values('r_pointbiserial', ascending=False)
corr_df['weight'] = (abs(corr_df['r_pointbiserial']) / abs(corr_df['r_pointbiserial']).sum()).round(3)

print("=== Korelasi Competency vs Top Performer ===")
print(corr_df)

"""# Psychometric Analysis

a) IQ, PAULI, FAXTOR, GTQ, TIKI
"""

# 1. Define numeric psychometric variables (adjust if needed)
num_cols = ['iq', 'pauli', 'faxtor', 'gtq', 'tiki']
num_cols = [c for c in num_cols if c in profiles_psych.columns]

# 2. Merge with employee performance data
psych = emp_perf[['employee_id', 'top_flag']].merge(profiles_psych, on='employee_id', how='left')

# 3. Encode top_flag as numeric (1 = Top Performer, 0 = Non-Top Performer)
psych['top_flag_num'] = psych['top_flag'].replace({'Top Performer': 1, 'Non-Top Performer': 0}).astype(int)

# 4. Convert psychometric columns to numeric and fill missing values
for c in num_cols:
    psych[c] = pd.to_numeric(psych[c], errors='coerce')
    psych[c] = psych[c].fillna(psych[c].median())

# 5. Compute correlations with performance flag
corrs = {c: psych[c].corr(psych['top_flag_num']) for c in num_cols}
corr_series = pd.Series(corrs).sort_values(ascending=False)
print("Correlation between psychometric variables and Top Performer flag:\n")
print(corr_series.round(3))

# 6. Visualize correlations as heatmap
plt.figure(figsize=(8,6))
sns.heatmap(psych[num_cols + ['top_flag_num']].corr(), annot=True, fmt='.2f', cmap='vlag', center=0)
plt.title("Correlation Matrix: Psychometric Variables vs Top Performer Flag", fontsize=12, weight='bold')
plt.tight_layout()
plt.show()

# 7. Visualize top features with strongest difference
top_features = corr_series.abs().sort_values(ascending=False).head(3).index.tolist()

for col in top_features:
    plt.figure(figsize=(5,3.5))
    sns.boxplot(
        x=psych['top_flag'],
        y=psych[col],
        palette='Blues',
        width=0.5
    )
    plt.title(f"{col} Distribution by Performer Group", fontsize=11, weight='bold')
    plt.xlabel("")
    plt.ylabel(col)
    plt.tight_layout()
    plt.show()

"""b) MBTI Analysis"""

if 'mbti' in psych.columns:
    psych['mbti_clean'] = (
        psych['mbti']
        .astype(str)
        .str.upper()
        .str.replace(r'\s+', '', regex=True)
    )

    valid_mbti = {
        'INTJ','INTP','ENTJ','ENTP','INFJ','INFP','ENFJ','ENFP',
        'ISTJ','ISFJ','ESTJ','ESFJ','ISTP','ISFP','ESTP','ESFP'
    }
    psych['mbti_clean'] = psych['mbti_clean'].where(psych['mbti_clean'].isin(valid_mbti), np.nan)

    mbti_tab = (
        pd.crosstab(psych['mbti_clean'], psych['top_flag_num'], normalize='index')
        .fillna(0) * 100
    )

    mbti_tab.columns = ['Non-Top Performer (%)', 'Top Performer (%)']

    print("\nðŸ”¹ Top Performer Percentage by MBTI Type:\n")
    display(mbti_tab.sort_values('Top Performer (%)', ascending=False).head(10))

    # --- Visualize ---
    plt.figure(figsize=(7,5))
    ax = sns.barplot(
        y=mbti_tab.index,
        x=mbti_tab['Top Performer (%)'],
        palette='mako'
    )
    plt.title("Top Performer Rate by MBTI Type", fontsize=12, weight='bold')
    plt.xlabel("Top Performer (%)")
    plt.ylabel("MBTI Type")


    for i, v in enumerate(mbti_tab['Top Performer (%)']):
        ax.text(v + 0.5, i, f"{v:.1f}%", va='center', fontsize=9)

    plt.tight_layout()
    plt.show()

# ---- MBTI Grouped Bar Chart (Top vs Non-Top) ----
if 'mbti_tab' in locals() and not mbti_tab.empty:
    mbti_sorted = mbti_tab.sort_values('Top Performer (%)', ascending=False).head(10)

    ax = mbti_sorted[['Top Performer (%)', 'Non-Top Performer (%)']].plot(
        kind='barh',
        stacked=False,
        figsize=(10,6),
        color=['#FFA726', '#90CAF9']
    )

    plt.title('MBTI Type Distribution: Top vs Non-Top Performers', fontsize=13, weight='bold')
    plt.xlabel('Percentage (%)')
    plt.ylabel('MBTI Type')
    plt.legend(title='Performer Type')
    plt.gca().invert_yaxis()


    for container in ax.containers:
        ax.bar_label(container, fmt='%.1f%%', label_type='edge', fontsize=9)

    plt.tight_layout()
    plt.show()

if 'mbti' in psych.columns:
    # --- Clean MBTI values ---
    psych['mbti_clean'] = (
        psych['mbti']
        .astype(str)
        .str.upper()
        .str.replace(r'\s+', '', regex=True)
    )

    valid_mbti = {
        'INTJ','INTP','ENTJ','ENTP','INFJ','INFP','ENFJ','ENFP',
        'ISTJ','ISFJ','ESTJ','ESFJ','ISTP','ISFP','ESTP','ESFP'
    }
    psych['mbti_clean'] = psych['mbti_clean'].where(psych['mbti_clean'].isin(valid_mbti), np.nan)

    # --- Split MBTI into 4 dimensions ---
    psych['EI'] = np.where(psych['mbti_clean'].str[0] == 'E', 'Extraversion', 'Introversion')
    psych['SN'] = np.where(psych['mbti_clean'].str[1] == 'S', 'Sensing', 'Intuition')
    psych['TF'] = np.where(psych['mbti_clean'].str[2] == 'T', 'Thinking', 'Feeling')
    psych['JP'] = np.where(psych['mbti_clean'].str[3] == 'J', 'Judging', 'Perceiving')

    # --- Combine all 8 categories into one long format ---
    mbti_long = psych.melt(
        id_vars=['top_flag_num'],
        value_vars=['EI', 'SN', 'TF', 'JP'],
        var_name='Dimension',
        value_name='Category'
    )

    # --- Calculate Top Performer percentage per category ---
    mbti_tab = (
        pd.crosstab(mbti_long['Category'], mbti_long['top_flag_num'], normalize='index')
        .fillna(0) * 100
    )
    mbti_tab.columns = ['Non-Top Performer (%)', 'Top Performer (%)']


    mbti_sorted = mbti_tab.sort_values('Top Performer (%)', ascending=False)

    print("\nðŸ”¹ Top Performer Percentage by MBTI Dimension:\n")
    display(mbti_sorted)

    # --- Visualization ---
    plt.figure(figsize=(7,5))
    ax = sns.barplot(
        data=mbti_sorted.reset_index(),
        y='Category',
        x='Top Performer (%)',
        palette='mako'
    )

    plt.title("Top Performer Rate by MBTI Dimension", fontsize=12, weight='bold')
    plt.xlabel("Top Performer (%)")
    plt.ylabel("MBTI Dimension")


    for i, v in enumerate(mbti_sorted['Top Performer (%)']):
        ax.text(v + 0.5, i, f"{v:.1f}%", va='center', fontsize=9)

    plt.tight_layout()
    plt.show()

"""c) DISC Analysis"""

if 'disc_word' in psych.columns:
    # Crosstab proporsi
    disc_word_tab = (
        pd.crosstab(psych['disc_word'], psych['top_flag'], normalize='index')
        .fillna(0) * 100
    )
    disc_word_tab.columns = ['Non-Top Performer (%)', 'Top Performer (%)']

    # Sort by Top Performer rate
    disc_word_sorted = disc_word_tab.sort_values('Top Performer (%)', ascending=False).head(10)

    # Tampilkan tabel top 10
    print("\nðŸ”¹ Top Performer Percentage by DISC (Word Description):\n")
    display(disc_word_sorted)

    # --- Visual ---
    plt.figure(figsize=(7,5))
    ax = sns.barplot(
        x='Top Performer (%)',
        y=disc_word_sorted.index,
        data=disc_word_sorted,
        palette='Blues_r'
    )


    plt.title("Top Performer Percentage by DISC (Word Description)", fontsize=13, weight='bold')
    plt.xlabel("Top Performer (%)")
    plt.ylabel("DISC Word Category")
    plt.grid(axis='x', linestyle='--', alpha=0.4)


    for i, v in enumerate(disc_word_sorted['Top Performer (%)']):
        ax.text(v + 0.5, i, f"{v:.1f}%", va='center', fontsize=9)

    plt.tight_layout()
    plt.show()

if 'disc_word' in psych.columns:
    disc_word_tab = (
        pd.crosstab(psych['disc_word'], psych['top_flag'], normalize='index')
        .fillna(0) * 100
    )
    disc_word_tab.columns = ['Non-Top Performer (%)', 'Top Performer (%)']
    disc_word_sorted = disc_word_tab.sort_values('Top Performer (%)', ascending=False).head(10)

    plt.figure(figsize=(10,6))
    disc_word_sorted[['Top Performer (%)', 'Non-Top Performer (%)']].plot(
        kind='barh',
        stacked=False,
        figsize=(10,6),
        color=['#42A5F5', '#FFB300']
    )
    plt.title('DISC (Word Description) â€“ Top vs Non-Top Performers', fontsize=13)
    plt.xlabel('Percentage (%)')
    plt.ylabel('DISC Word Category')
    plt.legend(title='Performer Type')
    plt.gca().invert_yaxis()
    plt.show()

if 'disc_word' in psych.columns:
    # --- Clean text ---
    psych['disc_word_clean'] = (
        psych['disc_word']
        .astype(str)
        .str.strip()
        .str.title()
    )

    # --- Split combined DISC traits into two columns ---
    disc_split = psych['disc_word_clean'].str.split('-', expand=True)
    psych['disc_1'] = disc_split[0]
    psych['disc_2'] = disc_split[1]

    # --- Convert into long format (one row per DISC trait) ---
    disc_long = psych.melt(
        id_vars=['top_flag_num'],
        value_vars=['disc_1', 'disc_2'],
        value_name='disc_trait'
    ).dropna(subset=['disc_trait'])


    mapping = {
        'Dominant': 'Dominance',
        'Dominance': 'Dominance',
        'Influencer': 'Influence',
        'Influence': 'Influence',
        'Steadiness': 'Steadiness',
        'Conscientious': 'Compliance',
        'Compliance': 'Compliance'
    }
    disc_long['disc_core'] = disc_long['disc_trait'].map(mapping)

    # --- Keep only valid DISC categories ---
    disc_long = disc_long.dropna(subset=['disc_core'])

    # --- Calculate Top Performer proportion per DISC category ---
    disc_tab = (
        pd.crosstab(disc_long['disc_core'], disc_long['top_flag_num'], normalize='index')
        .fillna(0) * 100
    )

    # --- Ensure consistent column naming ---
    if 0 in disc_tab.columns and 1 in disc_tab.columns:
        disc_tab.columns = ['Non-Top Performer (%)', 'Top Performer (%)']
    elif 1 in disc_tab.columns:
        disc_tab.columns = ['Top Performer (%)']
        disc_tab['Non-Top Performer (%)'] = 0
    elif 0 in disc_tab.columns:
        disc_tab.columns = ['Non-Top Performer (%)']
        disc_tab['Top Performer (%)'] = 0

    # --- Sort by Top Performer rate ---
    disc_tab_sorted = disc_tab.sort_values('Top Performer (%)', ascending=False)


    print("\nðŸ”¹ Top Performer Percentage by DISC Core Category:\n")
    display(disc_tab_sorted)

    # --- Visualization ---
    plt.figure(figsize=(7,5))
    ax = sns.barplot(
        data=disc_tab_sorted.reset_index(),
        x='Top Performer (%)',
        y='disc_core',
        palette='Blues_r'
    )
    plt.title("Top Performer Rate by DISC Core Category", fontsize=13, weight='bold')
    plt.xlabel("Top Performer (%)")
    plt.ylabel("DISC Core Type")
    plt.grid(axis='x', linestyle='--', alpha=0.4)


    for i, v in enumerate(disc_tab_sorted['Top Performer (%)']):
        ax.text(v + 0.5, i, f"{v:.1f}%", va='center', fontsize=9)

    plt.tight_layout()
    plt.show()

"""d) PAPI Analysis"""

# Merge PAPI scores with Top Performer flag
papi_summary = papi_scores.merge(emp_perf[['employee_id', 'top_flag']], on='employee_id', how='left')

# Ensure scores are numeric
papi_summary['score'] = pd.to_numeric(papi_summary['score'], errors='coerce')

# Calculate average score per PAPI scale for each group
papi_mean = (
    papi_summary
    .groupby(['scale_code', 'top_flag'])['score']
    .mean()
    .unstack()
    .fillna(0)
)

papi_mean = papi_mean[['Non-Top Performer', 'Top Performer']]
papi_mean['Diff'] = papi_mean['Top Performer'] - papi_mean['Non-Top Performer']
papi_mean = papi_mean.sort_values('Diff', ascending=False)

print("Average PAPI Scores (Top vs Non-Top Performer):\n")
display(papi_mean)

plt.figure(figsize=(12, 6))
sns.heatmap(papi_mean[['Non-Top Performer', 'Top Performer']], annot=True, cmap='coolwarm', fmt='.1f')
plt.title("Average PAPI Scores by Group (Top vs Non-Top Performer)", fontsize=13, weight='bold')
plt.xlabel("Category")
plt.ylabel("PAPI Scale")
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
ax = sns.barplot(
    x=papi_mean['Diff'],
    y=papi_mean.index,
    palette='RdYlGn'
)

plt.title("Difference in Average PAPI Scores (Top â€“ Non-Top Performer)", fontsize=13, weight='bold')
plt.xlabel("Score Difference")
plt.ylabel("PAPI Scale")

# --- Add a vertical reference line at 0 (neutral point) ---
plt.axvline(0, color='gray', linestyle='--', alpha=0.6)

# --- Add numeric labels at the end of each bar ---
for i, v in enumerate(papi_mean['Diff']):
    offset = 0.05 if v >= 0 else -0.15  # adjust position based on direction
    ha = 'left' if v >= 0 else 'right'
    ax.text(v + offset, i, f"{v:.2f}", va='center', ha=ha, fontsize=9)

plt.tight_layout()
plt.show()

"""# Behavioral Analysis"""

# 1. Ensure binary flag (1 = Top Performer, 0 = Non-Top)
emp_perf['top_flag_num'] = emp_perf['top_flag'].replace({'Top Performer': 1, 'Non-Top Performer': 0}).astype(int)

# 2. Merge employee with strengths dataset
strg = emp_perf[['employee_id', 'top_flag', 'top_flag_num']].merge(strengths, on='employee_id', how='left')

# 3. Check column availability
print("Columns in strengths:", strengths.columns.tolist())

if 'theme' in strg.columns and 'rank' in strg.columns:
# 4. Count frequency of each strength theme for Top vs Non-Top
    strength_freq = (
        strg.groupby(['theme', 'top_flag'])
        .size()
        .unstack(fill_value=0)
        .rename(columns={'Top Performer': 'Top', 'Non-Top Performer': 'Non-Top'})
    )

# 5. Calculate percentage and difference
    strength_freq['Total'] = strength_freq['Top'] + strength_freq['Non-Top']
    strength_freq['Top (%)'] = (strength_freq['Top'] / strength_freq['Total']) * 100
    strength_freq['Diff'] = strength_freq['Top (%)'] - 50  # difference from equal distribution (neutral baseline)

# 6. Sort by Top performer frequency
    top_strengths = strength_freq.sort_values('Top (%)', ascending=False)

    print("Top 10 Strength Themes (Top vs Non-Top):\n")
    display(top_strengths[['Top', 'Non-Top', 'Top (%)']].round(2))

# 7. Bar chart â€” Top Performer Only (with percentage labels)
plt.figure(figsize=(8,5))
ax = sns.barplot(
    x='Top (%)',
    y=top_strengths.index,
    data=top_strengths.reset_index(),
    palette='Blues_r'
)

plt.title("Strength Themes â€” Top Performers", fontsize=13, weight='bold')
plt.xlabel("Top Performer (%)")
plt.ylabel("Strength Theme")

# Add percentage labels on each bar
for i, v in enumerate(top_strengths['Top (%)']):
    ax.text(v + 0.2, i, f"{v:.1f}%", va='center', fontsize=8)

plt.tight_layout()
plt.show()

# FINAL CORRECT CALCULATION
top_strengths_only = (
    strg[strg['top_flag'] == 'Top Performer']
    .groupby('theme')
    .size()
    .reset_index(name='Count')
)

top_strengths_only['Top (%)'] = (top_strengths_only['Count'] / top_strengths_only['Count'].sum()) * 100
top_strengths_only = top_strengths_only.sort_values('Top (%)', ascending=False)

strg.head(5)

# --- Filter only top performers ---
top_strengths = strg[strg['top_flag'] == 'Top Performer']

# --- Count frequency per theme ---
top_strength_counts = (
    top_strengths.groupby('theme')['rank']
    .count()
    .sort_values(ascending=False)
)

# --- Convert to percentage ---
top_strength_pct = (top_strength_counts / top_strength_counts.sum()) * 100
top_strength_pct = top_strength_pct.head(10)  # Top 10 themes

# --- Display ---
print("Top 10 Strength Themes among Top Performers (%):\n")
display(top_strength_pct.round(2))

# --- Visualization ---
plt.figure(figsize=(8,4))
ax = sns.barplot(
    x=top_strength_pct.values,
    y=top_strength_pct.index,
    palette='Blues_r'
)

plt.title("Top 10 Strength Themes â€” Top Performers", fontsize=13, weight='bold')
plt.xlabel("Percentage of Top Performers (%)")
plt.ylabel("Strength Theme")

# --- Add percentage labels ---
for i, v in enumerate(top_strength_pct.values):
    ax.text(v + 0.3, i, f"{v:.1f}%", va='center', fontsize=9)

plt.tight_layout()
plt.show()